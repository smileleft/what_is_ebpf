# 9.2 eBPF 기반 성능 최적화 전략

# eBPF 기반 성능 최적화의 기본 원리

eBPF(extended Berkeley Packet Filter)는 리눅스 커널의 다양한 지점(훅 포인트)에 사용자 정의 프로그램을 안전하게 주입해 실행할 수 있게 해주는 기술. 

이 훅 포인트는 시스템 호출, 커널 함수 진입/복귀, 네트워크 이벤트, 스케줄링 이벤트 등 커널 내부의 주요 활동을 포괄.

eBPF 프로그램은 이러한 이벤트가 발생할 때 트리거되어 데이터를 수집, 필터링하거나 커널 동작을 제한된 범위 내에서 조절할 수 있슴. 

성능 최적화 관점에서 eBPF의 핵심 원리는 다음과 같음

- **커널 내 데이터 수집**: eBPF는 커널 공간에서 데이터를 직접 수집/처리하며, 사용자 공간으로 복사하지 않아도 되므로 컨텍스트 스위치 오버헤드가 줄어들고 분석 도구 자체의 부하가 낮음
- **프로그래밍 가능한 유연성**: 사용자는 특정 성능 문제에 맞춰 eBPF 프로그램을 맞춤형으로 작성할 수 있슴. 이는 고정된 지표만 제공하는 기존 도구 대비 큰 장점
- **JIT 컴파일을 통한 고성능**: eBPF 프로그램은 커널 로드시 JIT(Just-In-Time) 컴파일되어 호스트 CPU의 네이티브 명령어로 실행되므로 커널 모듈에 준하는 성능을 발휘
- **안전성 보장**: eBPF 검증기(Verifier)는 커널의 안전성과 안정성을 해치지 않도록 로드 전 정적 분석을 수행함

## 성능 최적화를 위한 eBPF 활용 전략

### CPU 성능 최적화

1. CPU 사용량 프로파일링
    - **원리**: perf_event 기반 샘플링 또는 `profile` 트레이싱을 통해 CPU의 스택 트레이스를 주기적으로 캡처. 사용자 및 커널 영역 모두 분석 가능
    - **전략**: 핫스팟 함수/코드를 식별하고 알고리즘 최적화 또는 불필요한 연산 제거
    - **도구**: `bcc/profile`, `bpftrace`, `perf`, `Parca`, `Pyroscope`
2. 컨텍스트 스위치 분석
    - **원리**: `schedule()`, `finish_task_switch()` 등을 후킹하여 스위치 횟수 및 원인(락 경합, I/O 대기 등) 분석
    - **전략**: 빈번한 컨텍스트 스위치를 유발하는 코드 식별 → 락 최적화 또는 병렬 모델 조정
    - **도구**: `bcc/cs_snoop`, `bpftrace`
3. Run Queue 지연 분석
    - **원리**: 프로세스가 대기열에 추가되고 CPU를 얻기까지의 지연 시간 측정\
    - **전략**: CPU 병목 여부 판단 → 코어 확장, 워크로드 분산, 우선순위 조정 등
    - **도구**: `bcc/runqlat`, `bpftrace`

### 메모리 성능 최적화

1. 메모리 할당/해제 추적
    - **원리**: `kmalloc`, `kfree`, `mmap`, `munmap` 또는 사용자 공간 `malloc` 후킹
    - **전략**: 불필요한 할당 제거, 메모리 누수 탐지, 객체 풀링 활용
    - **도구**: `bcc/memleak`, `bpftrace`, `bcc/kmemslab`
2. 페이지 폴트 분석
    - **원리**: `handle_mm_fault()` 등 모니터링 → 페이지 미스/스왑 발생 위치 추적
    - **전략**: 캐시 조정, 워킹 셋 최적화, 불필요한 파일 I/O 제거
    - **도구**: `bcc/ext4slower`, `bpftrace`

### 디스크 I/O 최적화

1. 파일 시스템 지연 분석
    - **원리**: `ext4_read_iter`, `xfs_file_read_iter` 등 후킹 → 지연 시간 측정
    - **전략**: 병목 파일 탐지 → SSD 이관, 캐싱 적용, 스케줄러 조정
    - **도구**: `bcc/fileslower`, `bcc/diskslower`, `bpftrace`
2. 디스크 큐 및 요청 분석
    - **원리**: 큐 깊이 및 I/O 요청 크기 측정
    - **전략**: 스케줄러 조정 (mq-deadline, bfq 등), 버퍼 크기 조절
    - **도구**: `bcc/blk_rq_stats`, `iostat`, `bpftrace`

### 네트워크 성능 분석

1. 지연 및 드롭(Drop) 분석
    - **원리**: NIC 드라이버(XDP), TC, 소켓 레벨에서 드롭/재전송/큐잉 분석
    - **전략**: MTU, 큐 설정, 혼잡 제어 알고리즘 최적화
    - **도구**: `bcc/dropwatch`, `bcc/tcpslows`, `Cilium`, `bpftrace`
2. 로드 밸런싱 추적 및 최적화
    - **원리**: `connect()`, `accept()` 후킹 → 백엔드 분산 분석
    - **전략**: 비효율적 분배 탐지 → 알고리즘 개선, 서비스 용량 조정
    - **도구**: `Cilium`, `bpftrace`, `Pixie`
3. 어플리케이션 계층(L7) 트래픽 분석
    - **원리**: HTTP/gRPC/DNS 패킷 파싱 및 지연/오류 코드 추적
    - **전략**: API 병목 탐지 → 쿼리 최적화, 캐싱 도입
    - **도구**: `Cilium + Hubble`, `Pixie`, eBPF Exporter

### eBPF 기반 성능 최적화의 장점

- **낮은 오버헤드**: 커널 내부에서 직접 실행되므로 기존 도구보다 훨씬 낮은 오버헤드를 제공
- **깊은 통찰력**: 시스템 호출, 내부 구조체, 함수 호출 등 커널 깊숙한 영역까지 접근 가능
- **코드 변경 불필요**: 애플리케이션 수정 없이 런타임에서 추적 가능
- **조건부 추적 지원**: PID, 유저 ID, 커맨드명, 파일 경로 등 특정 조건 기반의 정밀 추적
- **확장성**: 모니터링 외에도 보안, 네트워크 필터링, 정책 적용 등에도 활용 가능

### 고려사항 및 실무 적용 전략

- **커널 버전 호환성**: 최신 eBPF 기능은 리눅스 5.x 이상에서 안정적으로 제공되며, CO-RE(Compile Once, Run Everywhere)를 통해 다양한 커널에서 이식성 보장
- **보안 및 권한**: 루트 권한 및 검증기 통과 필요, 신뢰된 도구 또는 빌드 시스템 사용 권장
- **학습 난이도**: 커널 구조, C 언어, eBPF 맵/헬퍼 함수 등에 대한 학습 필요. `bpftrace`는 진입 장벽을 낮춰줌
